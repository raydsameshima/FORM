FORM 4.1 (May 11 2015) 64-bits                   Run: Sun Nov  1 15:56:50 2015
    * ttbarproduction.frm
    * Ray D. Sameshima
    * 
    *	Program for working out the matrix element squared for the
    *	reaction q,qbar -> t,tbar in QCD.
    * 
    *  \ q(p1)            / t(k1)
    *   \                /
    *    \g(j1)*T(c1)   /
    *     *^^^^^^^^^^^^*
    *    /  gprop       \ g(j2)*T(c2)
    *   /                \
    *  / qbar(p2)         \ tbar(k2)
    *
    * The input is the amplitude or i_*M
    *   Amp = VB(i1,p2,mq = 0,c1)*g(i1,i2,j1)*T(c1,c2,d1)*U(i2,p1,0,c2)*
    *         gprop(j1,j2,q,d1,d2)*
    *	        UB(i3,k1,mt=0,c3)*g(i3,i4,j2)*T(c3,c4,d2)*V(i4,k2,0,c4);
    * where c's are the colour indices, 
    * and d's are the label of generators(orientations in the group space) 
    * from 1 to N^2-1.
    
    #include qcdAmplitude.frm
    * qcdAmplitude.frm
    * Ray D. Sameshima
    * rewrite amplitude.frm for qcd (su(N=3) gauge theory)
    * Peskin & Schroeder notation, see Appendix A.
    * http://www.nikhef.nl/~t68/course/short.pdf
    
    Symbol N;
    Symbols [N^2-1];
    
    * i's are spinor indices, j's are Lorentz indices
    * c's are colour indices, d's are the label for su(N) generators
    * So, the generator for su(N) has indices like T(c1,c2,d1).
    AutoDeclare Indices i,j,c,d;
    * masses
    AutoDeclare Symbols m;
    * momemtums
    AutoDeclare Vectors p,k;
    * momentum transfer (dummy)
    Vectors q;
    * spinors, gamma matrices(g), polarization vector for photons(e), 
    * and Gell-Mann matrices(T)
    CFunctions  UB,U,VB,V, g, e, T;
    * U(i2,p1,m,c) =  U(spinorindex, momentum, mass, colourindex) 
    * gprop(j1?,j2?,q?,d1?,d2?) = -d_(j1,j2)*prop(q.q) * ddelta(d1,d2);
    CFunctions gprop,fprop,phprop,prop;
    * for contractions of indices c's and d's
    CFunction cdelta, ddelta;
    
    #procedure squareamplitude(Amp,Mat)
    .sort
    
    * We skip everything but Amp, i.e. only operate on Amp.
    * In Amp we look for the highest i(spinor) and j(Lorentz) indices
    Skip; NSkip `Amp';
    
    #$imax = 0;
    #do i = 1,40
    * naively assume 40 or less spinor indices
      if (  match(VB(i'i',?a)) || match(V(i`i',?a))
         || match(UB(i`i',?a)) || match(U(i`i',?a))
         || match(g(i`i',?a)) || match(g(i?,i`i',?a))
         || match(fprop(i`i',?a)) || match(fprop(i?,i`i',?a)) 
         );
         $imax = `i';
      endif;
    #enddo
    #$jmax = 0;
    #do j = 1,20
    * naively assume 20 or less Lorentz indices
      if (  match(g(?a,j`j')) || match(phprop(j`j',?a)) 
         || match(phprop(j?,j`j',?a)) 
         || match(gprop(j'j',?a))
         || match(gprop(j?,j'j',?a))
         );
         $jmax = `j';
      endif;
    #enddo
    #$cmax = 0;
    #do c = 1,40
    * naively assume 40 or less colour indices
      if (  match(VB(?a,c'c')) || match(V(?a,c'c'))
         || match(UB(?a,c'c')) || match(U(?a,c'c'))
         || match(T(c'c',?a))  || match(T(c?,c'c',?a))
         );
         $cmax = 'c';
      endif;
    #enddo
    #$dmax = 0;
    #do d = 1,20;
    * naively assume 20 or less generators(for su(3), N = 8)
      if( match(T(?a,d'd'))
        || match(gprop(?a,d'd',d?))
        || match(gprop(?a,d'd'))
        );
        $dmax = 'd';
      endif;
    #enddo
    
    .sort
    
    * Just for a check we print the highest i and j indices
    #message highest i is i`$imax', highest j is j`$jmax';
    #message highest c is c`$cmax', highest d is d`$dmax';
    
    * Now construct the conjugate
    Skip;
    Local `Amp'C = `Amp';
    id  i_ = -i_;
    
    * Make a new set of dummy indices above $imax and $jmax.
    * I haven't seen <> notation, but this should clarify the pair of replacement.
    Multiply replace_(<i1,i{`$imax'+1}>,...,<i`$imax',i{2*`$imax'}>);
    Multiply replace_(<j1,j{`$jmax'+1}>,...,<j`$jmax',j{2*`$jmax'}>);
    Multiply replace_(<c1,c{`$cmax'+1}>,...,<c`$cmax',c{2*`$cmax'}>);
    Multiply replace_(<d1,d{`$dmax'+1}>,...,<d`$dmax',d{2*`$dmax'}>);
    
    * Exchange rows and columns, i.e. takeing the transposes.
    id g(i1?,i2?,j?)      = g(i2,i1,j);
    id T(c1?,c2?,d?)      = T(c2,c1,d);
    id fprop(i1?,i2?,?a)  = fprop(i2,i1,?a);
    id phprop(j1?,j2?,q?) = phprop(j2,j1,q);
    id gprop(j1?,j2?,q?,d1?,d2?) = gprop(j2,j1,q,d2,d1);
    
    * and exchange U and UB, V and VBAR
    Multiply replace_(UB,U,U,UB,VB,V,V,VB);
    
    * gamma5 gets a minus sign. Hence k6 <--> k7
    Multiply replace_(k6,k7,k7,k6);
    id g(?a,k5) = -g(?a,k5);
    .sort
    * The end of the conjugations.
    
    * Now multiply Amp and AmpC to get the matrix element squared.
    Skip;
    * Drop(for efficiency): ... eliminates all expressions from the system
    * we won't use (manipulate) Amp,AmpC anymore.
    Drop,`Amp',`Amp'C;
    
    Local `Mat' = `Amp'*`Amp'C;
    
    * Spin sums, 1st terms are slashed p and 2nd terms are delta?
    * (A.22) of Peskin & Schroeder
    id U(i1?,p?,m?,c1?)*UB(i2?,p?,m?,c2?) = (g(i1,i2,p) + g(i1,i2)*m) * cdelta(c1,c2
    );
    id V(i1?,p?,m?,c1?)*VB(i2?,p?,m?,c2?) = (g(i1,i2,p) - g(i1,i2)*m) * cdelta(c1,c2
    );
    * for external photons (A.26)
    id e(j1?,p?)*e(j2?,p?) = -d_(j1,j2);
    
    * Propagators
    id fprop(i1?,i2?,p?,m?) = i_*(g(i1,i2,p)+g(i1,i2)*m)*prop(p.p-m^2);
    id phprop(j1?,j2?,q?) = -d_(j1,j2)*prop(q.q);
    id gprop(j1?,j2?,q?,d1?,d2?) = -d_(j1,j2)*prop(q.q) * ddelta(d1,d2);
    
    *   String the gamma matrices together in traces.
    repeat id g(i1?,i2?,?a)*g(i2?,i3?,?b) = g(i1,i3,?a,?b);
    .sort
    
    Skip; NSkip `Mat';
    
    *   Now put the traces one by one in terms of the built in gammas
    #do i = 1,10
      id, once, g(i1?,i1?,?a) = g_(`i',?a);
    * g7_ = 1-g5_, g6_ = 1+g5_
      id  g_(`i',k7) = g7_(`i');
      id  g_(`i',k6) = g6_(`i');
      id  g_(`i',k5) = g5_(`i');
    #enddo
    .sort
    
    * Finally take the traces, naively assuming less than 10 fermions.
    #do i = 1,10
      Trace4,`i';
    #enddo
    
    Bracket T;
    Print +s;
    * Print[];
    .sort
    * .end
    
    * qcd trace by hand
    * eq.(3.25) of QCD practice
    * ddelta
    id T(c1?, c2?, d1?)* ddelta(d1?,d2?) = T(c1,c2,d2);
    id T(c1?, c2?, d1?)* ddelta(d2?,d1?) = T(c1,c2,d2);
    repeat id T(c1?,c2?,d1?)*T(c3?,c4?,d1?) = 1/2 * (cdelta(c1,c4)*cdelta(c2,c3) - 1
    /N * cdelta(c1,c2)*cdelta(c3,c4));
    repeat id cdelta(c1?,c2?)*cdelta(c2?,c3?) = cdelta(c1,c3);
    repeat id cdelta(c1?,c2?)*cdelta(c3?,c2?) = cdelta(c1,c3);
    repeat id ddelta(d1?,d2?)*ddelta(d2?,d3?) = ddelta(d1,d3);
    repeat id ddelta(d1?,d2?)*ddelta(d3?,d2?) = ddelta(d1,d3);
    id cdelta(c1?,c1?) = N; 
    
    * Bracket T,N, ddelta,cdelta;
    * Print;
    * .sort
    ** .end
    id ddelta(d1?,d1?) = N^2-1;
    
    id N^2 = [N^2-1] + 1;
    
    Bracket [N^2-1];
    Print +s;
    * Print[];
    .sort
    * .end
    
    * id ddelta(d1?,d2?) = 0;
    * id cdelta(c1?,c2?) = 0;
    * .sort
    
    * Bracket N;
    * Print[];
    * .sort
    * .end
    
    #endprocedure
    
    Local Amp = VB(i1,p2,mq,c1)*g(i1,i2,j1)*T(c1,c2,d1)*U(i2,p1,mq,c2)*
                gprop(j1,j2,q,d1,d2)*
    *            phprop(j1,j2,q)*d_(d1,d2)*
                UB(i3,k1,mt,c3)*g(i3,i4,j2)*T(c3,c4,d2)*V(i4,k2,mt,c4);
    
    #call squareamplitude(Amp,M)

Time =       0.00 sec    Generated terms =          1
             Amp         Terms in output =          1
                         Bytes used      =        392

Time =       0.01 sec    Generated terms =          1
             Amp         Terms in output =          1
                         Bytes used      =        392
~~~highest i is i4, highest j is j2
~~~highest c is c4, highest d is d2

Time =       0.01 sec    Generated terms =          1
            AmpC         Terms in output =          1
                         Bytes used      =        392

Time =       0.01 sec    Generated terms =         16
               M         Terms in output =         16
                         Bytes used      =       8396

Time =       0.01 sec    Generated terms =         16
               M         Terms in output =         16
                         Bytes used      =       7836

Time =       0.01 sec    Generated terms =          8
               M         Terms in output =          5
                         Bytes used      =        676

   M =

       + T(c1,c2,d1)*T(c3,c4,d2)*T(c6,c5,d3)*T(c8,c7,d4) * (
          + 64*prop(q.q)^2*cdelta(c2,c6)*cdelta(c4,c8)*cdelta(c5,c1)*cdelta(c7
         ,c3)*ddelta(d1,d2)*ddelta(d4,d3)*mq^2*mt^2
          + 32*prop(q.q)^2*cdelta(c2,c6)*cdelta(c4,c8)*cdelta(c5,c1)*cdelta(c7
         ,c3)*ddelta(d1,d2)*ddelta(d4,d3)*p2.p1*mt^2
          + 32*prop(q.q)^2*cdelta(c2,c6)*cdelta(c4,c8)*cdelta(c5,c1)*cdelta(c7
         ,c3)*ddelta(d1,d2)*ddelta(d4,d3)*p2.k1*p1.k2
          + 32*prop(q.q)^2*cdelta(c2,c6)*cdelta(c4,c8)*cdelta(c5,c1)*cdelta(c7
         ,c3)*ddelta(d1,d2)*ddelta(d4,d3)*p2.k2*p1.k1
          + 32*prop(q.q)^2*cdelta(c2,c6)*cdelta(c4,c8)*cdelta(c5,c1)*cdelta(c7
         ,c3)*ddelta(d1,d2)*ddelta(d4,d3)*k1.k2*mq^2
          );


Time =       0.01 sec    Generated terms =         25
               M         Terms in output =          5
                         Bytes used      =        380

   M =

       + [N^2-1] * (
          + 16*prop(q.q)^2*mq^2*mt^2
          + 8*prop(q.q)^2*p2.p1*mt^2
          + 8*prop(q.q)^2*p2.k1*p1.k2
          + 8*prop(q.q)^2*p2.k2*p1.k1
          + 8*prop(q.q)^2*k1.k2*mq^2
          );

    .sort

Time =       0.01 sec    Generated terms =          5
               M         Terms in output =          5
                         Bytes used      =        408
    
    Symbols	s,t,u;
    
    id	prop(q.q) = 1/s;
    id	p1.p2 = s/2-mq^2;
    id	k1.k2 = s/2-mt^2;
    id	p1.k1 = mq^2/2+mt^2/2-t/2;
    id	p2.k2 = mq^2/2+mt^2/2-t/2;
    id	p1.k2 = mq^2/2+mt^2/2-u/2;
    id	p2.k1 = mq^2/2+mt^2/2-u/2;
    id	u = 2*mq^2+2*mt^2-s-t;
    
    id mq = 0;
    * id mt = 0;
    
    Bracket [N^2-1];
    Print +s;
    .sort

Time =       0.01 sec    Generated terms =         18
               M         Terms in output =          5
                         Bytes used      =        212

   M =

       + [N^2-1] * (
          + 2
          + 4*s^-2*t^2
          + 4*s^-1*t
          - 8*mt^2*s^-2*t
          + 4*mt^4*s^-2
          );

    #message Need to compare with the known result, see the following link:
~~~Need to compare with the known result, see the following link:
    #message http://arxiv.org/pdf/0806.2301.pdf
~~~http://arxiv.org/pdf/0806.2301.pdf
    
    Local solution = 2*[N^2-1]*((t-mt^2)^2 + (u-mt^2)^2 + 2*mt^2*s)/s^2;
    id u = 2*mt^2 -s-t;
    .sort

Time =       0.01 sec    Generated terms =          5
               M         Terms in output =          5
                         Bytes used      =        220

Time =       0.01 sec    Generated terms =         14
        solution         Terms in output =          5
                         Bytes used      =        220
    
    #message My solution is consistent with the known result. 
~~~My solution is consistent with the known result. 
    Local difference = M - solution;
    Print;
    Print;
    .end

Time =       0.01 sec    Generated terms =          5
               M         Terms in output =          5
                         Bytes used      =        220

Time =       0.01 sec    Generated terms =          5
        solution         Terms in output =          5
                         Bytes used      =        220

Time =       0.01 sec    Generated terms =         10
      difference         Terms in output =          0
                         Bytes used      =          4

   M =
      4*[N^2-1]*s^-2*t^2 + 4*[N^2-1]*s^-1*t + 2*[N^2-1] - 8*[N^2-1]*mt^2*s^-2*
      t + 4*[N^2-1]*mt^4*s^-2;

   solution =
      4*[N^2-1]*s^-2*t^2 + 4*[N^2-1]*s^-1*t + 2*[N^2-1] - 8*[N^2-1]*mt^2*s^-2*
      t + 4*[N^2-1]*mt^4*s^-2;

   difference = 0;

  0.01 sec out of 0.01 sec
