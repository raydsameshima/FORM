FORM 4.1 (May 11 2015) 64-bits                   Run: Tue Oct 27 13:05:19 2015
    * ttbarproduction.frm
    *
    *	Program for working out the matrix element squared for the
    *	reaction q,qbar -> t,tbar in QCD.
    * 
    *  \ q(p1)            / t(k1)
    *   \                /
    *    \g(j1)*T(c1)   /
    *     *^^^^^^^^^^^^*
    *    /  gprop       \ g(j2)*T(c2)
    *   /                \
    *  / qbar(p2)         \ tbar(k2)
    *
    * The input is the amplitude or i_*M
    *   Amp = VB(i1,p2,mq = 0,c1)*g(i1,i2,j1)*T(c1,c2,d1)*U(i2,p1,0,c2)*
    *         gprop(j1,j2,q,d1,d2)*
    *	        UB(i3,k1,mt=0,c3)*g(i3,i4,j2)*T(c3,c4,d2)*V(i4,k2,0,c4);
    * where c's are the colour indices, 
    * and d's are the label of generators(orientations in the group space) 
    * from 1 to N^2-1.
    
    #include qcdAmplitude.frm
    * qcdAmplitude.frm
    * Ray D. Sameshima
    * rewrite amplitude.frm for qcd (su(N=3) gauge theory)
    * Peskin & Schroeder notation, see Appendix A.
    * http://www.nikhef.nl/~t68/course/short.pdf
    
    Symbol N;
    
    * i's are spinor indices, j's are Lorentz indices
    * c's are colour indices, d's are the label for su(N) generators
    * So, the generator for su(N) has indices like T(c1,c2,d1).
    AutoDeclare Indices i,j,c,d;
    * masses
    AutoDeclare Symbols m;
    * momemtums
    AutoDeclare Vectors p,k;
    * momentum transfer (dummy)
    Vectors q;
    * spinors, gamma matrices(g), polarization vector for photons(e), 
    * and Gell-Mann matrices(T)
    CFunctions  UB,U,VB,V, g, e, T;
    * U(i2,p1,m,c) =  U(spinorindex, momentum, mass, colourindex) 
    * gprop(j1?,j2?,q?,d1?,d2?) = -d_(j1,j2)*prop(q.q) * ddelta(d1,d2);
    CFunctions gprop,fprop,phprop,prop;
    * for contractions of indices c's and d's
    CFunction cdelta, ddelta;
    
    #procedure squareamplitude(Amp,Mat)
    .sort
    
    * We skip everything but Amp, i.e. only operate on Amp.
    * In Amp we look for the highest i(spinor) and j(Lorentz) indices
    Skip; NSkip `Amp';
    
    #$imax = 0;
    #do i = 1,40
    * naively assume 40 or less spinor indices
      if (  match(VB(i'i',?a)) || match(V(i`i',?a))
         || match(UB(i`i',?a)) || match(U(i`i',?a))
         || match(g(i`i',?a)) || match(g(i?,i`i',?a))
         || match(fprop(i`i',?a)) || match(fprop(i?,i`i',?a)) 
         );
         $imax = `i';
      endif;
    #enddo
    #$jmax = 0;
    #do j = 1,20
    * naively assume 20 or less Lorentz indices
      if (  match(g(?a,j`j')) || match(phprop(j`j',?a)) 
         || match(phprop(j?,j`j',?a)) 
         || match(gprop(j'j',?a))
         || match(gprop(j?,j'j',?a))
         );
         $jmax = `j';
      endif;
    #enddo
    #$cmax = 0;
    #do c = 1,40
    * naively assume 40 or less colour indices
      if (  match(VB(?a,c'c')) || match(V(?a,c'c'))
         || match(UB(?a,c'c')) || match(U(?a,c'c'))
         || match(T(c'c',?a))  || match(T(c?,c'c',?a))
         );
         $cmax = 'c';
      endif;
    #enddo
    #$dmax = 0;
    #do d = 1,20;
    * naively assume 20 or less generators(for su(3), N = 8)
      if( match(T(?a,d'd'))
        || match(gprop(?a,d'd',d?))
        || match(gprop(?a,d'd'))
        );
        $dmax = 'd';
      endif;
    #enddo
    
    .sort
    
    * Just for a check we print the highest i and j indices
    #message highest i is i`$imax', highest j is j`$jmax';
    #message highest c is c`$cmax', highest d is d`$dmax';
    
    * Now construct the conjugate
    Skip;
    Local `Amp'C = `Amp';
    id  i_ = -i_;
    
    * Make a new set of dummy indices above $imax and $jmax.
    * I haven't seen <> notation, but this should clarify the pair of replacement.
    Multiply replace_(<i1,i{`$imax'+1}>,...,<i`$imax',i{2*`$imax'}>);
    Multiply replace_(<j1,j{`$jmax'+1}>,...,<j`$jmax',j{2*`$jmax'}>);
    
    * Exchange rows and columns, i.e. takeing the transposes.
    id g(i1?,i2?,j?)      = g(i2,i1,j);
    id T(c1?,c2?,d?)      = T(c2,c1,d);
    id fprop(i1?,i2?,?a)  = fprop(i2,i1,?a);
    id phprop(j1?,j2?,q?) = phprop(j2,j1,q);
    id gprop(j1?,j2?,q?,d1?,d2?) = gprop(j2,j1,q,d2,d1);
    
    * and exchange U and UB, V and VBAR
    Multiply replace_(UB,U,U,UB,VB,V,V,VB);
    
    * gamma5 gets a minus sign. Hence k6 <--> k7
    Multiply replace_(k6,k7,k7,k6);
    id g(?a,k5) = -g(?a,k5);
    .sort
    * The end of the conjugations.
    
    * Now multiply Amp and AmpC to get the matrix element squared.
    Skip;
    * Drop(for efficiency): ... eliminates all expressions from the system
    * we won't use (manipulate) Amp,AmpC anymore.
    Drop,`Amp',`Amp'C;
    
    Local `Mat' = `Amp'*`Amp'C;
    
    * Spin sums, 1st terms are slashed p and 2nd terms are delta?
    * (A.22) of Peskin & Schroeder
    id U(i1?,p?,m?,c1?)*UB(i2?,p?,m?,c2?) = (g(i1,i2,p) + g(i1,i2)*m) * cdelta(c1,c2
    );
    id V(i1?,p?,m?,c1?)*VB(i2?,p?,m?,c2?) = (g(i1,i2,p) - g(i1,i2)*m) * cdelta(c1,c2
    );
    * for external photons (A.26)
    id e(j1?,p?)*e(j2?,p?) = -d_(j1,j2);
    
    * Propagators
    id fprop(i1?,i2?,p?,m?) = i_*(g(i1,i2,p)+g(i1,i2)*m)*prop(p.p-m^2);
    id phprop(j1?,j2?,q?) = -d_(j1,j2)*prop(q.q);
    id gprop(j1?,j2?,q?,d1?,d2?) = -d_(j1,j2)*prop(q.q) * ddelta(d1,d2);
    
    *   String the gamma matrices together in traces.
    repeat id g(i1?,i2?,?a)*g(i2?,i3?,?b) = g(i1,i3,?a,?b);
    .sort
    
    Skip; NSkip `Mat';
    
    *   Now put the traces one by one in terms of the built in gammas
    #do i = 1,10
      id, once, g(i1?,i1?,?a) = g_(`i',?a);
    * g7_ = 1-g5_, g6_ = 1+g5_
      id  g_(`i',k7) = g7_(`i');
      id  g_(`i',k6) = g6_(`i');
      id  g_(`i',k5) = g5_(`i');
    #enddo
    .sort
    
    * Finally take the traces, naively assuming less than 10 fermions.
    #do i = 1,10
      Trace4,`i';
    #enddo
    
    * qcd trace by hand
    * eq.(3.25) of QCD practice
    repeat id T(c1?,c2?,d1?)*T(c3?,c4?,d1?) = 1/2 * (cdelta(c1,c4)*cdelta(c2,c3) - 1
    /N * cdelta(c1,c2)*cdelta(c3,c4));
    repeat id cdelta(c1?,c2?)*cdelta(c2?,c3?) = cdelta(c1,c3);
    repeat id ddelta(d1?,d2?)*ddelta(d2?,d3?) = ddelta(d1,d3);
    id ddelta(d1?,d1?) = N^2-1;
    id cdelta(c1?,c1?) = N; 
    .sort
    
    #endprocedure
    
    Local Amp = VB(i1,p2,mq,c1)*g(i1,i2,j1)*T(c1,c2,d1)*U(i2,p1,mq,c2)*
                gprop(j1,j2,q,d1,d2)*
    *            phprop(j1,j2,q)*d_(d1,d2)*
                UB(i3,k1,mt,c3)*g(i3,i4,j2)*T(c3,c4,d2)*V(i4,k2,mt,c4);
    
    #call squareamplitude(Amp,M)

Time =       0.00 sec    Generated terms =          1
             Amp         Terms in output =          1
                         Bytes used      =        392

Time =       0.01 sec    Generated terms =          1
             Amp         Terms in output =          1
                         Bytes used      =        392
~~~highest i is i4, highest j is j2
~~~highest c is c4, highest d is d2

Time =       0.01 sec    Generated terms =          1
            AmpC         Terms in output =          1
                         Bytes used      =        392

Time =       0.01 sec    Generated terms =         16
               M         Terms in output =         16
                         Bytes used      =       8396

Time =       0.01 sec    Generated terms =         16
               M         Terms in output =         16
                         Bytes used      =       7836

Time =       0.01 sec    Generated terms =         64
               M         Terms in output =         20
                         Bytes used      =        856
    .sort

Time =       0.01 sec    Generated terms =         20
               M         Terms in output =         20
                         Bytes used      =        856
    
    Symbols	s,t,u;
    
    id	prop(q.q) = 1/s;
    id	p1.p2 = s/2-mq^2;
    id	k1.k2 = s/2-mt^2;
    id	p1.k1 = mq^2/2+mt^2/2-t/2;
    id	p2.k2 = mq^2/2+mt^2/2-t/2;
    id	p1.k2 = mq^2/2+mt^2/2-u/2;
    id	p2.k1 = mq^2/2+mt^2/2-u/2;
    id	u = 2*mq^2+2*mt^2-s-t;
    
    id mq = 0;
    id mt = 0;
    
    Print +s;
    .end

Time =       0.01 sec    Generated terms =         16
               M         Terms in output =         12
                         Bytes used      =        428

   M =
       - 2
       - 4*s^-2*t^2
       - 4*s^-1*t
       + 12*N^2*s^-2*t^2
       + 12*N^2*s^-1*t
       + 6*N^2
       - 12*N^4*s^-2*t^2
       - 12*N^4*s^-1*t
       - 6*N^4
       + 4*N^6*s^-2*t^2
       + 4*N^6*s^-1*t
       + 2*N^6
      ;

  0.01 sec out of 0.01 sec

*********************
by using Maxima
(%i9) M, ratsimp;

(%o9) ((4*t^2+4*s*t+2*s^2)*N^6+((-12*t^2)-12*s*t-6*s^2)*N^4
                              +(12*t^2+12*s*t+6*s^2)*N^2-4*t^2-4*s*t-2*s^2)
